/* Copyright 2007--2009 Theodore S. Norvell. All rights reserved.   Updated 2009 Mar 12 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,      this list of conditions and the following disclaimer.   2. Redistributions in binary form must reproduce the above copyright notice,      this list of conditions and the following disclaimer in the documentation      and/or other materials provided with the distribution.   3. Neither the source nor binary form shall be included in any product used by      or intended for use by any military organization. THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITYAND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THEODORENORVELL BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, ORCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTEGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USEOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.*/package monitor;/** A condition queue. * <p> * Uses the signal and wait discipline (SW) or signal and leave (SL). * <p> * Each Condition object is associated with a single Assertion object * and a single <code>AbstractMonitor</code> object. To construct * a condition use the <code>makeCondition</code> methods from * <code>{@link AbstractMonitor}</code>. * <p> * Threads can wait for the assertion represented by the Assertion * object to become true by calling method <code>await()</code>. * Threads can indicate that the assertion has become true by calling * either method <code>signal()</code> (SW) or <code>signalAndLeave()</code> * (SL). All these methods check the assertion and the monitor's invariant * as appropriate. * <p> * Each of the <code>await()</code>, <code>signal()</code>, and * <code>signalAndLeave()</code> methods have corresponding condition * versions, that first check the assertion before awaiting or signalling. * These are: <code>conditionalAwait()</code>, <code>conditionalSignal()</code>, and * <code>conditionalSignalAndLeave()</code>. * <p> * Conditions also support accessors to determine the number of threads * waiting on the condition. * <p> * Condition objects are intended to be used only by the thread that * occupies the monitor that created them.  *  * @author Theodore S. Norvell * @version 1.0 * @see AbstractMonitor*/public class Condition{    final private AbstractMonitor homeMonitor ;    final private Assertion assertion ;    final private Semaphore queue ;    volatile private int count ;    final private String name ;    Condition( String _name, AbstractMonitor _homeMonitor, Assertion _assertion ) {    	name = _name ;        homeMonitor = _homeMonitor ;        assertion = _assertion ;        queue = new Semaphore(0) ;        count = 0 ; }        public String getName() {    	return name ; }    /** Wait until a condition is signalled.      * The thread waits outside the monitor until the      * condition is signalled.      * <p> Precondition: Increasing the count by 1      *     must make the invariant true.      *     This thread is in the monitor.      * <p> Postcondition: The assertion associated      * @throws AssertionError if the current thread is not the occupant.      *     with this condition queue. This thread is in the monitor.      * @throws AssertionError if the invariant is not true to start      * @throws AssertionError if the assertion is not true on return      */    public void await() {    	homeMonitor.notifyCallAwait(this) ;        Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;        count += 1 ;        Assertion.check( homeMonitor.invariant() ) ;        homeMonitor.occupant = null ;        homeMonitor.entrance.release() ;        queue.acquire() ;        count -= 1 ;        homeMonitor.occupant = Thread.currentThread() ;        // It's not clear that the following check is needed anymore,        // as there is now a check made on the signal.        assertion.check() ;    	homeMonitor.notifyReturnFromAwait( this ) ;    }    /** Wait only if the condition is not already true.      * @throws AssertionError if neither the invariant nor the assertion associated      * with this object is true      * @throws AssertionError if the current thread is not the occupant.      * @throws AssertionError if the assertion is not true on return     * */    public void conditionalAwait() {        if( ! assertion.isTrue() ) await() ; }    /** Signal this condition if there is a waiting thread.     * Allows one thread that was waiting on the condition to reenter the monitor.     * Consequently the signalling thread waits outside.     * If there is no waiting thread, then this is a no-op, but the invariant is still     * checked.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>The monitor's invariant.     *          <li>This thread is in the monitor.     *      </ul>     *            * @throws AssertionError if the current thread is not the occupant.      * @throws AssertionError if there is a waiting thread and the      *         assertion is false (after decreasing the count by 1).      * @throws AssertionError if invariant is false on return.      *             */    public void signal() {    	    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;                if( count > 0 ) {            try{ count -= 1; assertion.check() ; } finally { count += 1 ; }             homeMonitor.occupant = null ;        	homeMonitor.notifySignallerLeavesTemporarily( this ) ;        	homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;            queue.release() ;            homeMonitor.entrance.acquire() ;        	            homeMonitor.occupant = Thread.currentThread() ;             homeMonitor.notifySignallerReenters( this ) ; }        Assertion.check( homeMonitor.invariant() ) ;    }    /** Signal if there is a waiting thread, then leave the monitor.     * Allows one thread that was     *  waiting on the condition to reenter the monitor.     *  This thread leaves the monitor immediately.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition: This thread is not in the monitor.     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1).     * @throws AssertionError there is no waiting thread and the invariant is false.    */    public void signalAndLeave()  {    	    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;                if( count > 0 ) {            try{ count -= 1; assertion.check() ; } finally { count += 1 ; }             homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;            homeMonitor.occupant = null ;            queue.release() ; }                else {            Assertion.check( homeMonitor.invariant() ) ;            homeMonitor.occupant = null ;            homeMonitor.entrance.release() ; }        homeMonitor.notifySignallerLeavesMonitor( this ) ;        }    /** Signal if there is a waiting thread, then leave the monitor.     * Allows one thread that was     *  waiting on the condition to reenter the monitor.     *  This thread leaves the monitor immediately.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>If not isEmpty(), then decreasing count() by 1 must make     *          the proposition associated with this condition true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition: This thread is not in the monitor.     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1).     * @throws AssertionError there is no waiting thread and the invariant is false.     * @return The argument.    */    public <T> T signalAndLeave(T result)  {    	signalAndLeave() ;        return result ; }        /** Signal this condition if its assertion is true and there is a waiting thread.     * More precisely the condition is only signalled if     * the assertion would be true after the count is     * decreased by 1.     *  <p> Preconditions:     *      <ul><li>If isEmpty(), the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>The monitor's invariant.     *          <li>This thread is in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     * @throws AssertionError if invariant is false on return.    */    public void conditionalSignal() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;        	if( count > 0 ) {    		boolean wouldBeTrue ;    		count -= 1 ; wouldBeTrue = assertion.isTrue() ; count += 1 ;    		if( wouldBeTrue ) {    			homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;    			homeMonitor.notifySignallerLeavesTemporarily( this ) ;    			homeMonitor.occupant = null ;    			queue.release() ;    			    	        homeMonitor.entrance.acquire() ;    			homeMonitor.notifySignallerReenters( this ) ;    			homeMonitor.occupant = Thread.currentThread() ; } }        Assertion.check( homeMonitor.invariant() ) ;    }    /** Signal if the condition is true and there is a waiting thread. Leave regardless .     * More precisely the condition is only signalled if     * the assertion would be true after the count is     * decreased by 1.     *      *  <p> Preconditions:     *      <ul><li>If isEmpty() or the assertion would     *           be false after decreasing the count by 1,     *           the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>This thread is not in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     *  @throws AssertionError there is no waiting thread and the invariant is false.     *  @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1)     *         and the invariant is false.     *     */    public void conditionalSignalAndLeave()  {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;     	if( count > 0 ) {    		boolean wouldBeTrue ;    		count -= 1 ; wouldBeTrue = assertion.isTrue() ; count += 1 ;    		if( wouldBeTrue ) {    			homeMonitor.notifySignallerAwakesAwaitingThread( this ) ;    			homeMonitor.notifySignallerLeavesMonitor( this ) ;    			homeMonitor.occupant = null ;    			queue.release() ; }    		else {    			homeMonitor.notifySignallerLeavesMonitor( this ) ;    			homeMonitor.leaveWithoutATrace() ; } }    	else {    		homeMonitor.notifySignallerLeavesMonitor( this ) ;    		homeMonitor.leaveWithoutATrace() ; }    }    /** Signal if the condition is true and there is a waiting thread. Leave regardless.     * More precisely the condition is only signalled if     * the assertion would be true after the count is     * decreased by 1.     *      *  <p> Preconditions:     *      <ul><li>If isEmpty() or the assertion would     *           be false after decreasing the count by 1,     *           the monitor's invariant must be true.</li>     *          <li>This thread is in the monitor.</li>     *      </ul>     *  <p> Postcondition:     *      <ul><li>This thread is not in the monitor.     *      </ul>     *           * @throws AssertionError if the current thread is not the occupant.     *  @throws AssertionError there is no waiting thread and the invariant is false.     *  @throws AssertionError if there is a waiting thread and the     *         assertion is false (after decreasing the count by 1)     *         and the invariant is false.     * @return The argument.     *     */    public <T> T conditionalSignalAndLeave(T result)  {    	conditionalSignalAndLeave() ;    	return result ;    }    /** Test if any thread is waiting on this condition.      * @throws AssertionError if the current thread is not the occupant.      * @return count() == 0 .    */    public boolean isEmpty() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;    	return count == 0 ; }    /** How many thread are waiting on this condition.      * @throws AssertionError if the current thread is not the occupant.      * @return the number of Threads waiting on this condition.    */    public int count() {    	Assertion.check( homeMonitor.occupant == Thread.currentThread(), "Thread is not occupant") ;    	return count ; }}